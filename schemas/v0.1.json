{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://oatf.io/schemas/v0.1.json",
  "title": "Open Agent Threat Format (OATF) v0.1",
  "description": "Schema for validating OATF documents that describe security threats against AI agent communication protocols (MCP, A2A, AG-UI).",
  "type": "object",
  "required": [
    "oatf",
    "attack"
  ],
  "additionalProperties": false,
  "properties": {
    "$schema": {
      "type": "string",
      "format": "uri",
      "description": "URL pointing to this JSON Schema for IDE validation and autocompletion."
    },
    "oatf": {
      "type": "string",
      "const": "0.1",
      "description": "The OATF specification version. Must be \"0.1\" for this schema."
    },
    "attack": {
      "$ref": "#/$defs/Attack",
      "description": "The attack definition. Exactly one per document."
    }
  },
  "$defs": {
    "SeverityLevel": {
      "type": "string",
      "enum": [
        "informational",
        "low",
        "medium",
        "high",
        "critical"
      ],
      "description": "Severity classification from informational (observation only) to critical (full compromise)."
    },
    "Protocol": {
      "type": "string",
      "pattern": "^[a-z][a-z0-9_]*$",
      "description": "Agent communication protocol identifier. Open string; v0.1 defines: mcp, a2a, ag_ui. Used by indicators to specify which protocol's traffic to match against."
    },
    "Mode": {
      "type": "string",
      "pattern": "^[a-z][a-z0-9_]*_(server|client)$",
      "description": "Attacker posture: {protocol}_{role} convention. Open string; v0.1 defines: mcp_server, mcp_client, a2a_server, a2a_client, ag_ui_client. The protocol component (before _server/_client) identifies the binding; the role determines client vs server behavior."
    },
    "Impact": {
      "type": "string",
      "enum": [
        "behavior_manipulation",
        "data_exfiltration",
        "data_tampering",
        "unauthorized_actions",
        "information_disclosure",
        "credential_theft",
        "service_disruption",
        "privilege_escalation"
      ],
      "description": "Category of harm: what happens when the attack succeeds."
    },
    "Duration": {
      "type": "string",
      "pattern": "^([0-9]+[smhd]|P[0-9]+D(T([0-9]+H([0-9]+M)?([0-9]+S)?|[0-9]+M([0-9]+S)?|[0-9]+S))?|PT([0-9]+H([0-9]+M)?([0-9]+S)?|[0-9]+M([0-9]+S)?|[0-9]+S))$",
      "description": "Time duration. Shorthand (30s, 5m, 1h, 2d) or ISO 8601 (PT30S, PT5M30S, P1DT12H).",
      "examples": [
        "30s",
        "5m",
        "1h",
        "PT30S",
        "PT5M30S",
        "P1DT12H"
      ]
    },
    "Surface": {
      "type": "string",
      "description": "Protocol-specific attack surface being examined. Values for v0.1 bindings are defined in the protocol binding sections (spec ยง7). Surfaces for unrecognized bindings are structurally valid; tools MUST skip surface validation for unrecognized protocols.",
      "examples": [
        "tool_description",
        "tool_title",
        "tool_input_schema",
        "tool_name",
        "tool_icons",
        "tool_response",
        "tool_arguments",
        "resource_content",
        "resource_uri",
        "resource_title",
        "resource_icons",
        "prompt_content",
        "prompt_title",
        "prompt_icons",
        "server_info",
        "server_instructions",
        "agent_card",
        "skill_description",
        "task_message",
        "message_history",
        "tool_result",
        "agent_state"
      ]
    },
    "MatchCondition": {
      "type": "object",
      "description": "A single condition operator or combination of operators (AND logic). At least one operator key (contains, starts_with, ends_with, regex, any_of, gt, lt, gte, lte, exists) MUST be present.",
      "properties": {
        "contains": {
          "type": "string",
          "description": "Substring match (case-sensitive)."
        },
        "starts_with": {
          "type": "string",
          "description": "Prefix match (case-sensitive)."
        },
        "ends_with": {
          "type": "string",
          "description": "Suffix match (case-sensitive)."
        },
        "regex": {
          "type": "string",
          "description": "RE2-compatible regular expression. No lookarounds, no backreferences."
        },
        "any_of": {
          "type": "array",
          "description": "Match any of the listed values (OR logic). Deep equality: arrays compare element-wise, objects compare key-value pairs ignoring key order.",
          "minItems": 1,
          "items": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              },
              {
                "type": "boolean"
              },
              {
                "type": "null"
              },
              {
                "type": "array"
              },
              {
                "type": "object"
              }
            ]
          }
        },
        "gt": {
          "type": "number",
          "description": "Greater than."
        },
        "lt": {
          "type": "number",
          "description": "Less than."
        },
        "gte": {
          "type": "number",
          "description": "Greater than or equal."
        },
        "lte": {
          "type": "number",
          "description": "Less than or equal."
        },
        "exists": {
          "type": "boolean",
          "description": "Field presence check. true: matches if the path resolved to a value (including null). false: matches if the path did not resolve."
        }
      },
      "additionalProperties": false,
      "anyOf": [
        {
          "required": [
            "contains"
          ]
        },
        {
          "required": [
            "starts_with"
          ]
        },
        {
          "required": [
            "ends_with"
          ]
        },
        {
          "required": [
            "regex"
          ]
        },
        {
          "required": [
            "any_of"
          ]
        },
        {
          "required": [
            "gt"
          ]
        },
        {
          "required": [
            "lt"
          ]
        },
        {
          "required": [
            "gte"
          ]
        },
        {
          "required": [
            "lte"
          ]
        },
        {
          "required": [
            "exists"
          ]
        }
      ]
    },
    "Attack": {
      "type": "object",
      "description": "A single attack definition containing metadata, execution profile, and optionally detection indicators.",
      "required": [
        "execution"
      ],
      "dependentRequired": {
        "correlation": [
          "indicators"
        ]
      },
      "additionalProperties": false,
      "patternProperties": {
        "^x-": {}
      },
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[A-Z][A-Z0-9-]*-[0-9]{3,}$",
          "description": "Unique stable identifier. Format: {PREFIX}-{NUMBER}. The OATF- prefix is reserved for the official public registry. Optional for local development.",
          "examples": [
            "OATF-001",
            "OATF-027",
            "ACME-001"
          ]
        },
        "name": {
          "type": "string",
          "default": "Untitled",
          "description": "Human-readable name for the attack. SHOULD be concise (under 80 characters). Defaults to \"Untitled\" when omitted.",
          "examples": [
            "Tool Description Prompt Injection",
            "Tool Definition Rug Pull"
          ]
        },
        "version": {
          "type": "integer",
          "minimum": 1,
          "default": 1,
          "description": "Document version. Monotonically increasing positive integer. Higher is newer.",
          "examples": [
            1,
            2,
            3
          ]
        },
        "status": {
          "type": "string",
          "enum": [
            "draft",
            "experimental",
            "stable",
            "deprecated"
          ],
          "default": "draft",
          "description": "Lifecycle status: draft -> experimental -> stable -> deprecated."
        },
        "created": {
          "anyOf": [
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            }
          ],
          "description": "Date/time first published. ISO 8601 datetime (2026-01-15T10:30:00Z) or bare date (2026-01-15).",
          "examples": [
            "2026-01-15T10:30:00Z",
            "2026-01-15"
          ]
        },
        "modified": {
          "anyOf": [
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            }
          ],
          "description": "Date/time last modified. ISO 8601 datetime or bare date.",
          "examples": [
            "2026-02-15T14:00:00Z",
            "2026-02-15"
          ]
        },
        "author": {
          "type": "string",
          "description": "Author or organization that created this document.",
          "examples": [
            "ThoughtJack Project"
          ]
        },
        "description": {
          "type": "string",
          "description": "Prose description of the attack: what it does, why it matters, what conditions enable it."
        },
        "grace_period": {
          "$ref": "#/$defs/Duration",
          "description": "Post-terminal-phase observation window. Duration to continue observing after all terminal phases complete before computing the final verdict."
        },
        "severity": {
          "$ref": "#/$defs/Severity",
          "description": "Threat level. Accepts scalar string (\"high\") or full object with level and confidence. Optional; absent when not assessed."
        },
        "impact": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Impact"
          },
          "uniqueItems": true,
          "description": "Categories of harm this attack can cause."
        },
        "classification": {
          "$ref": "#/$defs/Classification"
        },
        "references": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Reference"
          },
          "description": "External references: research papers, blog posts, CVE entries, related OATF documents."
        },
        "execution": {
          "$ref": "#/$defs/ExecutionProfile"
        },
        "indicators": {
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "#/$defs/Indicator"
          },
          "description": "Patterns for determining whether the agent complied with this attack. Optional; when absent the document is valid for simulation only."
        },
        "correlation": {
          "type": "object",
          "description": "How indicator verdicts combine to produce the attack-level verdict.",
          "additionalProperties": false,
          "properties": {
            "logic": {
              "type": "string",
              "enum": [
                "any",
                "all"
              ],
              "default": "any",
              "description": "How indicator verdicts combine. any: at least one indicator matched means exploited. all: every indicator must match."
            }
          }
        }
      }
    },
    "Severity": {
      "oneOf": [
        {
          "$ref": "#/$defs/SeverityLevel",
          "description": "Scalar shorthand. Expands to {level: <value>, confidence: 50}."
        },
        {
          "type": "object",
          "description": "Full severity specification with confidence.",
          "required": [
            "level"
          ],
          "additionalProperties": false,
          "properties": {
            "level": {
              "$ref": "#/$defs/SeverityLevel"
            },
            "confidence": {
              "type": "integer",
              "minimum": 0,
              "maximum": 100,
              "default": 50,
              "description": "Confidence in the assigned severity level (0-100, STIX scale). 0 = no confidence, 100 = certain."
            }
          }
        }
      ]
    },
    "Classification": {
      "type": "object",
      "description": "Maps the attack to external security frameworks and the OATF category taxonomy.",
      "additionalProperties": false,
      "properties": {
        "category": {
          "type": "string",
          "enum": [
            "capability_poisoning",
            "response_fabrication",
            "context_manipulation",
            "oversight_bypass",
            "temporal_manipulation",
            "availability_disruption",
            "cross_protocol_chain"
          ],
          "description": "Cross-protocol attack category. Describes type of attack independent of which protocol it targets."
        },
        "mappings": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/FrameworkMapping"
          },
          "description": "Mappings to external security frameworks (ATLAS, ATT&CK, OWASP, CWE, etc.)."
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Free-form tags for filtering and discovery. Should be lowercase and hyphenated.",
          "examples": [
            [
              "injection",
              "rug-pull",
              "multi-phase"
            ]
          ]
        }
      }
    },
    "FrameworkMapping": {
      "type": "object",
      "description": "Mapping to an entry in an external security framework.",
      "required": [
        "framework",
        "id"
      ],
      "additionalProperties": false,
      "properties": {
        "framework": {
          "type": "string",
          "minLength": 1,
          "description": "The external framework being referenced. Recommended values: atlas, mitre_attack, owasp_llm, owasp_mcp, owasp_agentic, cwe. Any string is accepted for custom or future frameworks.",
          "examples": [
            "atlas",
            "mitre_attack",
            "owasp_llm",
            "owasp_mcp",
            "owasp_agentic",
            "cwe",
            "other"
          ]
        },
        "id": {
          "type": "string",
          "description": "The identifier of the specific entry within the framework.",
          "examples": [
            "AML.T0051.002",
            "T1195.002",
            "TA0001",
            "MCP-03",
            "ASI-01",
            "LLM01",
            "CWE-74"
          ]
        },
        "name": {
          "type": "string",
          "description": "Human-readable name of the referenced entry.",
          "examples": [
            "Indirect Prompt Injection",
            "Supply Chain Compromise"
          ]
        },
        "url": {
          "type": "string",
          "format": "uri",
          "description": "Permalink to the referenced entry in the framework's documentation."
        },
        "relationship": {
          "type": "string",
          "enum": [
            "primary",
            "related"
          ],
          "default": "primary",
          "description": "How closely this attack maps to the referenced entry. Primary = directly implements; related = associated but not a direct implementation."
        }
      }
    },
    "Reference": {
      "type": "object",
      "description": "External reference providing context for the attack.",
      "required": [
        "url"
      ],
      "additionalProperties": false,
      "properties": {
        "url": {
          "type": "string",
          "format": "uri",
          "description": "URL of the reference."
        },
        "title": {
          "type": "string",
          "description": "Human-readable title of the reference."
        },
        "description": {
          "type": "string",
          "description": "Brief description of the reference's relevance."
        }
      }
    },
    "ExecutionProfile": {
      "type": "object",
      "description": "Specifies the protocol messages an adversarial tool must produce. Supports three mutually exclusive forms: single-phase (mode + state), multi-phase (phases, mode optional), or multi-actor (actors array).",
      "additionalProperties": false,
      "patternProperties": {
        "^x-": {}
      },
      "oneOf": [
        {
          "description": "Single-phase form: mode + state, no phases/actors.",
          "required": [
            "mode",
            "state"
          ],
          "not": {
            "anyOf": [
              {
                "required": [
                  "phases"
                ]
              },
              {
                "required": [
                  "actors"
                ]
              }
            ]
          }
        },
        {
          "description": "Multi-phase form: phases (mode optional), no state/actors.",
          "required": [
            "phases"
          ],
          "not": {
            "anyOf": [
              {
                "required": [
                  "state"
                ]
              },
              {
                "required": [
                  "actors"
                ]
              }
            ]
          }
        },
        {
          "description": "Multi-actor form: actors, no mode/state/phases.",
          "required": [
            "actors"
          ],
          "not": {
            "anyOf": [
              {
                "required": [
                  "mode"
                ]
              },
              {
                "required": [
                  "state"
                ]
              },
              {
                "required": [
                  "phases"
                ]
              }
            ]
          }
        }
      ],
      "properties": {
        "mode": {
          "$ref": "#/$defs/Mode",
          "description": "Attacker posture. Required in single-phase form."
        },
        "state": {
          "type": "object",
          "description": "Protocol-specific state for this single-phase attack."
        },
        "phases": {
          "type": "array",
          "minItems": 1,
          "prefixItems": [
            {
              "allOf": [
                { "$ref": "#/$defs/Phase" },
                { "required": ["state"] }
              ]
            }
          ],
          "items": {
            "$ref": "#/$defs/Phase"
          },
          "description": "Ordered sequence of attack phases."
        },
        "actors": {
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "#/$defs/Actor"
          },
          "description": "Named concurrent actors, each targeting a protocol endpoint."
        }
      }
    },
    "Actor": {
      "type": "object",
      "description": "A named concurrent protocol endpoint in a multi-actor execution profile.",
      "required": [
        "name",
        "mode",
        "phases"
      ],
      "additionalProperties": false,
      "patternProperties": {
        "^x-": {}
      },
      "properties": {
        "name": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9_]*$",
          "description": "Unique actor identifier. Used in cross-actor extractor references ({{actor_name.extractor_name}})."
        },
        "mode": {
          "$ref": "#/$defs/Mode",
          "description": "Attacker posture for this actor."
        },
        "phases": {
          "type": "array",
          "minItems": 1,
          "prefixItems": [
            {
              "allOf": [
                { "$ref": "#/$defs/Phase" },
                { "required": ["state"] }
              ]
            }
          ],
          "items": {
            "$ref": "#/$defs/Phase"
          },
          "description": "Ordered phase sequence for this actor."
        }
      }
    },
    "Phase": {
      "type": "object",
      "description": "A distinct stage of the attack. Phases execute in declared order.",
      "additionalProperties": false,
      "patternProperties": {
        "^x-": {}
      },
      "properties": {
        "name": {
          "type": "string",
          "description": "Human-readable label for this phase. Auto-generated as 'phase-{N}' (1-based) when omitted. Must be unique within the actor when specified.",
          "examples": [
            "trust_building",
            "payload_delivery",
            "exploit",
            "exfiltration"
          ]
        },
        "description": {
          "type": "string",
          "description": "Prose describing the purpose of this phase."
        },
        "mode": {
          "$ref": "#/$defs/Mode",
          "description": "Attacker posture for this phase. Defaults to execution.mode. Required when execution.mode is absent."
        },
        "state": {
          "type": "object",
          "description": "Protocol state for this phase. When omitted, inherits the entire state from the preceding phase (full replacement, no merging). Required on the first phase of each actor. Structure is protocol-specific and defined by the relevant binding (spec ยง7). Binding-specific state validation is the responsibility of binding-aware tools."
        },
        "extractors": {
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "#/$defs/Extractor"
          },
          "description": "Capture values from protocol messages for use in subsequent phases via {{name}} template syntax."
        },
        "on_enter": {
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "#/$defs/Action"
          },
          "description": "Actions executed when this phase begins, before any client interaction. When present, must contain at least one action."
        },
        "trigger": {
          "$ref": "#/$defs/Trigger",
          "description": "Condition that triggers advancement to the next phase. Omit for terminal phase (persists indefinitely)."
        }
      }
    },
    "Extractor": {
      "type": "object",
      "description": "Captures a value from a protocol message for use in subsequent phases and response templates.",
      "required": [
        "name",
        "source",
        "type",
        "selector"
      ],
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "Variable name. Referenced as {{name}} in templates. Last-write-wins if redefined in a later phase.",
          "examples": [
            "admin_tool_name",
            "session_id"
          ],
          "pattern": "^[a-z][a-z0-9_]*$"
        },
        "source": {
          "type": "string",
          "enum": [
            "request",
            "response"
          ],
          "description": "Extract from incoming requests or outgoing responses."
        },
        "type": {
          "type": "string",
          "enum": [
            "json_path",
            "regex"
          ],
          "description": "Extraction method. json_path: JSONPath expression (RFC 9535, first node in document order). regex: first match, first capture group."
        },
        "selector": {
          "type": "string",
          "description": "Extraction selector, interpreted according to type.",
          "examples": [
            "$.tools[0].name",
            "\"name\":\\s*\"([^\"]+)\""
          ]
        }
      }
    },
    "Action": {
      "type": "object",
      "description": "An action executed on phase entry. Exactly one action key per object (V-043). Known actions defined inline in each oneOf branch; binding-specific actions in the catch-all branch.",
      "oneOf": [
        {
          "required": [
            "send_notification"
          ],
          "additionalProperties": false,
          "patternProperties": {
            "^x-": {}
          },
          "properties": {
            "send_notification": {
              "type": "object",
              "description": "Send a protocol notification.",
              "required": [
                "method"
              ],
              "additionalProperties": false,
              "properties": {
                "method": {
                  "type": "string",
                  "description": "Notification method name.",
                  "examples": [
                    "notifications/tools/list_changed",
                    "notifications/resources/updated"
                  ]
                },
                "params": {
                  "type": "object",
                  "description": "Notification parameters."
                }
              }
            }
          }
        },
        {
          "required": [
            "log"
          ],
          "additionalProperties": false,
          "patternProperties": {
            "^x-": {}
          },
          "properties": {
            "log": {
              "type": "object",
              "description": "Emit a log message.",
              "required": [
                "message"
              ],
              "additionalProperties": false,
              "properties": {
                "message": {
                  "type": "string",
                  "description": "Log message text. Supports {{template}} interpolation."
                },
                "level": {
                  "type": "string",
                  "enum": [
                    "info",
                    "warn",
                    "error"
                  ],
                  "description": "Log severity level."
                }
              }
            }
          }
        },
        {
          "required": [
            "send_elicitation"
          ],
          "additionalProperties": false,
          "patternProperties": {
            "^x-": {}
          },
          "properties": {
            "send_elicitation": {
              "type": "object",
              "description": "Send an elicitation request to the client (MCP server-mode only).",
              "required": [
                "message"
              ],
              "additionalProperties": false,
              "properties": {
                "message": {
                  "type": "string",
                  "description": "Human-readable prompt for the elicitation."
                },
                "mode": {
                  "type": "string",
                  "enum": [
                    "form",
                    "url"
                  ],
                  "default": "form",
                  "description": "Elicitation mode."
                },
                "requestedSchema": {
                  "type": "object",
                  "description": "JSON Schema for form mode fields."
                },
                "elicitationId": {
                  "type": "string",
                  "description": "Unique ID for the elicitation (url mode). Auto-generated by the runtime if omitted."
                },
                "url": {
                  "type": "string",
                  "description": "URL for url mode."
                }
              }
            }
          }
        },
        {
          "description": "Binding-specific entry action (no known action keys). At least one non-x- key must be present; exact 'one non-x- key' enforcement is SDK-level (V-043).",
          "not": {
            "anyOf": [
              {
                "required": [
                  "send_notification"
                ]
              },
              {
                "required": [
                  "log"
                ]
              },
              {
                "required": [
                  "send_elicitation"
                ]
              },
              {
                "propertyNames": {
                  "pattern": "^x-"
                }
              }
            ]
          },
          "minProperties": 1,
          "additionalProperties": {}
        }
      ]
    },
    "Trigger": {
      "type": "object",
      "description": "Condition for phase advancement. Combines event matching, counting, content predicates, and duration-based advancement.",
      "additionalProperties": false,
      "dependentRequired": {
        "count": [
          "event"
        ],
        "match": [
          "event"
        ]
      },
      "properties": {
        "event": {
          "type": "string",
          "description": "Protocol event type to match. Uses protocol-native naming (slash-separated for MCP/A2A, snake_case for AG-UI). Supports qualifier via colon syntax for simple filtering. Must be valid for the actor's mode per the Event-Mode Validity Matrix (spec ยง7).",
          "pattern": "^[a-z][a-zA-Z0-9_/]*(:[a-zA-Z0-9_-]+)?$",
          "examples": [
            "tools/call",
            "tools/call:calculator",
            "tools/list",
            "elicitation/create",
            "tasks/get",
            "tasks/result",
            "notifications/tasks/status",
            "message/send",
            "task/status:completed",
            "agent_card/get",
            "tasks/pushNotification/set",
            "sampling/createMessage",
            "tool_call_start:transfer_funds",
            "run_started",
            "custom:my_event"
          ]
        },
        "count": {
          "type": "integer",
          "minimum": 1,
          "description": "Number of matching events required before advancing. Defaults to 1 when event is present. Must not appear without event. Accumulates within the current phase; resets to zero on phase transition."
        },
        "match": {
          "$ref": "#/$defs/MatchPredicate",
          "description": "Content predicate. Phase advances only when both event type and predicate match."
        },
        "after": {
          "$ref": "#/$defs/Duration",
          "description": "Advance unconditionally after this duration from phase entry."
        }
      },
      "anyOf": [
        {
          "required": [
            "event"
          ]
        },
        {
          "required": [
            "after"
          ]
        }
      ]
    },
    "MatchPredicate": {
      "type": "object",
      "description": "Structured conditions against protocol message content. Keys are dot-path field references (e.g., arguments.command). All conditions combine with AND. String operators are case-sensitive.",
      "additionalProperties": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          },
          {
            "type": "boolean"
          },
          {
            "type": "array"
          },
          {
            "type": "null"
          },
          {
            "type": "object",
            "$comment": "Bare-object equality. Objects containing any MatchCondition operator key must validate against the MatchCondition ref instead.",
            "not": {
              "anyOf": [
                { "required": ["contains"] },
                { "required": ["starts_with"] },
                { "required": ["ends_with"] },
                { "required": ["regex"] },
                { "required": ["any_of"] },
                { "required": ["gt"] },
                { "required": ["lt"] },
                { "required": ["gte"] },
                { "required": ["lte"] },
                { "required": ["exists"] }
              ]
            }
          },
          {
            "$ref": "#/$defs/MatchCondition"
          }
        ]
      },
      "propertyNames": {
        "pattern": "^([a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)*)?$",
        "description": "Simple dot-path field references (e.g., arguments.command). Empty string targets the root. No wildcards or array indices."
      }
    },
    "Indicator": {
      "type": "object",
      "description": "Pattern for determining whether the agent complied with the attack. Targets a specific protocol surface using exactly one of: pattern, expression, or semantic.",
      "required": [
        "surface"
      ],
      "additionalProperties": false,
      "patternProperties": {
        "^x-": {}
      },
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier within this document. Auto-generated when omitted. Format validated by SDK (see V-024).",
          "examples": [
            "OATF-003-01",
            "OATF-027-03",
            "ACME-001-01",
            "indicator-01"
          ]
        },
        "protocol": {
          "$ref": "#/$defs/Protocol",
          "description": "Protocol this indicator applies to. Defaults to the protocol component of execution.mode. Required when execution.mode is absent."
        },
        "surface": {
          "$ref": "#/$defs/Surface"
        },
        "description": {
          "type": "string",
          "description": "Prose describing what this indicator detects and why it is significant."
        },
        "pattern": {
          "$ref": "#/$defs/PatternMatch"
        },
        "expression": {
          "$ref": "#/$defs/ExpressionMatch"
        },
        "semantic": {
          "$ref": "#/$defs/SemanticMatch"
        },
        "confidence": {
          "type": "integer",
          "minimum": 0,
          "maximum": 100,
          "description": "Indicator-level confidence (0-100), overrides attack-level severity.confidence."
        },
        "severity": {
          "$ref": "#/$defs/SeverityLevel",
          "description": "Indicator-level severity override (level only). Overrides attack.severity.level for this indicator."
        },
        "false_positives": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Known benign scenarios that may trigger this indicator. Helps tool operators tune alerting."
        }
      },
      "oneOf": [
        {
          "required": [
            "pattern"
          ]
        },
        {
          "required": [
            "expression"
          ]
        },
        {
          "required": [
            "semantic"
          ]
        }
      ]
    },
    "PatternMatch": {
      "type": "object",
      "description": "String and structural pattern matching against parsed protocol messages. Standard form uses target + condition. Shorthand places a single condition operator directly on the pattern object.",
      "properties": {
        "target": {
          "type": "string",
          "pattern": "^([a-zA-Z0-9_-]+(\\[\\*\\])?(\\.[a-zA-Z0-9_-]+(\\[\\*\\])?)*)?$",
          "description": "Dot-path to the field to inspect. Supports wildcards (tools[*].description). Defaults to surface's canonical target (spec ยง7).",
          "examples": [
            "tools[*].description",
            "content[*]",
            "messages[*].content"
          ]
        },
        "condition": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "number"
            },
            {
              "type": "boolean"
            },
            {
              "type": "array"
            },
            {
              "type": "null"
            },
            {
              "type": "object",
              "$comment": "Bare-object equality. Objects containing any MatchCondition operator key must validate against the MatchCondition ref instead.",
              "not": {
                "anyOf": [
                  { "required": ["contains"] },
                  { "required": ["starts_with"] },
                  { "required": ["ends_with"] },
                  { "required": ["regex"] },
                  { "required": ["any_of"] },
                  { "required": ["gt"] },
                  { "required": ["lt"] },
                  { "required": ["gte"] },
                  { "required": ["lte"] },
                  { "required": ["exists"] }
                ]
              }
            },
            {
              "$ref": "#/$defs/MatchCondition"
            }
          ],
          "description": "Matching condition applied to target node(s). A single operator object, or a bare value for equality matching. Required in standard form."
        },
        "contains": {
          "type": "string",
          "description": "Shorthand: substring match on surface default target."
        },
        "starts_with": {
          "type": "string",
          "description": "Shorthand: prefix match on surface default target."
        },
        "ends_with": {
          "type": "string",
          "description": "Shorthand: suffix match on surface default target."
        },
        "regex": {
          "type": "string",
          "description": "Shorthand: RE2 regex on surface default target."
        },
        "any_of": {
          "type": "array",
          "description": "Shorthand: match any listed value on surface default target.",
          "minItems": 1,
          "items": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              },
              {
                "type": "boolean"
              },
              {
                "type": "null"
              },
              {
                "type": "array"
              },
              {
                "type": "object"
              }
            ]
          }
        },
        "gt": {
          "type": "number",
          "description": "Shorthand: greater than on surface default target."
        },
        "lt": {
          "type": "number",
          "description": "Shorthand: less than on surface default target."
        },
        "gte": {
          "type": "number",
          "description": "Shorthand: greater than or equal on surface default target."
        },
        "lte": {
          "type": "number",
          "description": "Shorthand: less than or equal on surface default target."
        }
      },
      "additionalProperties": false,
      "oneOf": [
        {
          "description": "Standard form: explicit target and condition.",
          "required": [
            "condition"
          ],
          "not": {
            "anyOf": [
              {
                "required": [
                  "contains"
                ]
              },
              {
                "required": [
                  "starts_with"
                ]
              },
              {
                "required": [
                  "ends_with"
                ]
              },
              {
                "required": [
                  "regex"
                ]
              },
              {
                "required": [
                  "any_of"
                ]
              },
              {
                "required": [
                  "gt"
                ]
              },
              {
                "required": [
                  "lt"
                ]
              },
              {
                "required": [
                  "gte"
                ]
              },
              {
                "required": [
                  "lte"
                ]
              }
            ]
          }
        },
        {
          "description": "Shorthand form: single condition operator using surface default target.",
          "not": {
            "anyOf": [
              {
                "required": [
                  "condition"
                ]
              },
              {
                "required": [
                  "target"
                ]
              }
            ]
          },
          "minProperties": 1,
          "anyOf": [
            {
              "required": [
                "contains"
              ],
              "not": {
                "anyOf": [
                  {
                    "required": [
                      "starts_with"
                    ]
                  },
                  {
                    "required": [
                      "ends_with"
                    ]
                  },
                  {
                    "required": [
                      "regex"
                    ]
                  },
                  {
                    "required": [
                      "any_of"
                    ]
                  },
                  {
                    "required": [
                      "gt"
                    ]
                  },
                  {
                    "required": [
                      "lt"
                    ]
                  },
                  {
                    "required": [
                      "gte"
                    ]
                  },
                  {
                    "required": [
                      "lte"
                    ]
                  }
                ]
              }
            },
            {
              "required": [
                "starts_with"
              ],
              "not": {
                "anyOf": [
                  {
                    "required": [
                      "contains"
                    ]
                  },
                  {
                    "required": [
                      "ends_with"
                    ]
                  },
                  {
                    "required": [
                      "regex"
                    ]
                  },
                  {
                    "required": [
                      "any_of"
                    ]
                  },
                  {
                    "required": [
                      "gt"
                    ]
                  },
                  {
                    "required": [
                      "lt"
                    ]
                  },
                  {
                    "required": [
                      "gte"
                    ]
                  },
                  {
                    "required": [
                      "lte"
                    ]
                  }
                ]
              }
            },
            {
              "required": [
                "ends_with"
              ],
              "not": {
                "anyOf": [
                  {
                    "required": [
                      "contains"
                    ]
                  },
                  {
                    "required": [
                      "starts_with"
                    ]
                  },
                  {
                    "required": [
                      "regex"
                    ]
                  },
                  {
                    "required": [
                      "any_of"
                    ]
                  },
                  {
                    "required": [
                      "gt"
                    ]
                  },
                  {
                    "required": [
                      "lt"
                    ]
                  },
                  {
                    "required": [
                      "gte"
                    ]
                  },
                  {
                    "required": [
                      "lte"
                    ]
                  }
                ]
              }
            },
            {
              "required": [
                "regex"
              ],
              "not": {
                "anyOf": [
                  {
                    "required": [
                      "contains"
                    ]
                  },
                  {
                    "required": [
                      "starts_with"
                    ]
                  },
                  {
                    "required": [
                      "ends_with"
                    ]
                  },
                  {
                    "required": [
                      "any_of"
                    ]
                  },
                  {
                    "required": [
                      "gt"
                    ]
                  },
                  {
                    "required": [
                      "lt"
                    ]
                  },
                  {
                    "required": [
                      "gte"
                    ]
                  },
                  {
                    "required": [
                      "lte"
                    ]
                  }
                ]
              }
            },
            {
              "required": [
                "any_of"
              ],
              "not": {
                "anyOf": [
                  {
                    "required": [
                      "contains"
                    ]
                  },
                  {
                    "required": [
                      "starts_with"
                    ]
                  },
                  {
                    "required": [
                      "ends_with"
                    ]
                  },
                  {
                    "required": [
                      "regex"
                    ]
                  },
                  {
                    "required": [
                      "gt"
                    ]
                  },
                  {
                    "required": [
                      "lt"
                    ]
                  },
                  {
                    "required": [
                      "gte"
                    ]
                  },
                  {
                    "required": [
                      "lte"
                    ]
                  }
                ]
              }
            },
            {
              "required": [
                "gt"
              ],
              "not": {
                "anyOf": [
                  {
                    "required": [
                      "contains"
                    ]
                  },
                  {
                    "required": [
                      "starts_with"
                    ]
                  },
                  {
                    "required": [
                      "ends_with"
                    ]
                  },
                  {
                    "required": [
                      "regex"
                    ]
                  },
                  {
                    "required": [
                      "any_of"
                    ]
                  },
                  {
                    "required": [
                      "lt"
                    ]
                  },
                  {
                    "required": [
                      "gte"
                    ]
                  },
                  {
                    "required": [
                      "lte"
                    ]
                  }
                ]
              }
            },
            {
              "required": [
                "lt"
              ],
              "not": {
                "anyOf": [
                  {
                    "required": [
                      "contains"
                    ]
                  },
                  {
                    "required": [
                      "starts_with"
                    ]
                  },
                  {
                    "required": [
                      "ends_with"
                    ]
                  },
                  {
                    "required": [
                      "regex"
                    ]
                  },
                  {
                    "required": [
                      "any_of"
                    ]
                  },
                  {
                    "required": [
                      "gt"
                    ]
                  },
                  {
                    "required": [
                      "gte"
                    ]
                  },
                  {
                    "required": [
                      "lte"
                    ]
                  }
                ]
              }
            },
            {
              "required": [
                "gte"
              ],
              "not": {
                "anyOf": [
                  {
                    "required": [
                      "contains"
                    ]
                  },
                  {
                    "required": [
                      "starts_with"
                    ]
                  },
                  {
                    "required": [
                      "ends_with"
                    ]
                  },
                  {
                    "required": [
                      "regex"
                    ]
                  },
                  {
                    "required": [
                      "any_of"
                    ]
                  },
                  {
                    "required": [
                      "gt"
                    ]
                  },
                  {
                    "required": [
                      "lt"
                    ]
                  },
                  {
                    "required": [
                      "lte"
                    ]
                  }
                ]
              }
            },
            {
              "required": [
                "lte"
              ],
              "not": {
                "anyOf": [
                  {
                    "required": [
                      "contains"
                    ]
                  },
                  {
                    "required": [
                      "starts_with"
                    ]
                  },
                  {
                    "required": [
                      "ends_with"
                    ]
                  },
                  {
                    "required": [
                      "regex"
                    ]
                  },
                  {
                    "required": [
                      "any_of"
                    ]
                  },
                  {
                    "required": [
                      "gt"
                    ]
                  },
                  {
                    "required": [
                      "lt"
                    ]
                  },
                  {
                    "required": [
                      "gte"
                    ]
                  }
                ]
              }
            }
          ]
        }
      ]
    },
    "ExpressionMatch": {
      "type": "object",
      "description": "CEL expression evaluated against the full message context. No target field; the expression itself navigates to relevant fields.",
      "required": [
        "cel"
      ],
      "additionalProperties": false,
      "properties": {
        "cel": {
          "type": "string",
          "description": "Common Expression Language expression evaluating to boolean. Must be side-effect-free. Available context is protocol-specific (spec ยง7.1.3, ยง7.2.3, ยง7.3.3).",
          "examples": [
            "message.tools.exists(t, size(t.description) > 500 && t.description.contains(\"IMPORTANT:\"))",
            "message.method == \"notifications/tools/list_changed\""
          ]
        },
        "variables": {
          "type": "object",
          "propertyNames": {
            "pattern": "^[_a-zA-Z][_a-zA-Z0-9]*$",
            "description": "Variable names must be valid CEL identifiers (V-041)."
          },
          "additionalProperties": {
            "type": "string",
            "pattern": "^([a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)*)?$"
          },
          "description": "Named variables pre-extracted via dot-path, available to the CEL expression beyond the root message context."
        }
      }
    },
    "SemanticMatch": {
      "type": "object",
      "description": "Intent-based detection requiring an inference engine (LLM, embedding model, or classifier). Threshold is tool-relative; cross-tool interoperability depends on the examples field.",
      "required": [
        "intent"
      ],
      "additionalProperties": false,
      "properties": {
        "target": {
          "type": "string",
          "pattern": "^([a-zA-Z0-9_-]+(\\[\\*\\])?(\\.[a-zA-Z0-9_-]+(\\[\\*\\])?)*)?$",
          "description": "Dot-path to the field to analyze. Defaults to surface's canonical target (spec ยง7).",
          "examples": [
            "tools[*].description",
            "skills[*].description"
          ]
        },
        "intent": {
          "type": "string",
          "description": "Natural-language description of the malicious intent to detect. Used as reference for similarity or classification.",
          "examples": [
            "Override agent behavior by impersonating system instructions within a tool description"
          ]
        },
        "intent_class": {
          "type": "string",
          "enum": [
            "prompt_injection",
            "data_exfiltration",
            "privilege_escalation",
            "social_engineering",
            "instruction_override"
          ],
          "description": "Class of malicious intent for classification-based engines."
        },
        "threshold": {
          "type": "number",
          "minimum": 0.0,
          "maximum": 1.0,
          "description": "Tool-relative confidence threshold (0.0-1.0). When absent, SDKs apply 0.7 at evaluation time. Not comparable across tools using different models. Calibrate using the examples field."
        },
        "examples": {
          "type": "object",
          "description": "Ground truth for calibrating inference engines. Documents should include at least 2 positive and 2 negative examples.",
          "additionalProperties": false,
          "minProperties": 1,
          "properties": {
            "positive": {
              "type": "array",
              "minItems": 1,
              "items": {
                "type": "string"
              },
              "description": "Strings that should trigger this indicator."
            },
            "negative": {
              "type": "array",
              "minItems": 1,
              "items": {
                "type": "string"
              },
              "description": "Strings that should not trigger this indicator."
            }
          }
        }
      }
    },
    "SynthesizeBlock": {
      "type": "object",
      "$comment": "Intentionally unreferenced by the core schema. Synthesize blocks appear inside binding-specific state (free-form object). Binding-aware validators and code generators should extract and $ref this definition for protocol-specific validation.",
      "description": "LLM-powered response generation request. Contains a prompt for runtime LLM synthesis. Model selection, temperature, and other generation parameters are runtime concerns, not part of the document (spec ยง7.4). This definition is not $ref'd by the core schema because synthesize blocks appear inside binding-specific state (which is free-form); it is provided for binding-aware tools to reuse.",
      "required": ["prompt"],
      "additionalProperties": false,
      "properties": {
        "prompt": {
          "type": "string",
          "minLength": 1,
          "description": "Free-text prompt for the LLM. Supports {{template}} interpolation from extractors and request fields. Must be non-empty (V-035)."
        }
      }
    }
  }
}
